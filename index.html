<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Emotion AI</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
<script src="https://cdn.tailwindcss.com"></script>

<style>
    /* ‚úÖ Background image with working overlay */
    body {
        font-family: 'Inter', sans-serif;
       background: 
    linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)),
    url('https://images.unsplash.com/photo-1633113214866-b7fdc014be8a?auto=format&fit=crop&w=1920&q=80');

        background-size: cover;
        background-position: center center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #111827;
    }

    h1 {
        font-family: 'Poppins', sans-serif;
    }

    .card {
        background: rgba(255, 255, 255, 0.9);
        padding: 2.5rem;
        border-radius: 1.5rem;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
        max-width: 32rem;
        width: 100%;
        text-align: center;
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn {
        @apply px-7 py-3 rounded-xl font-semibold text-white shadow-lg transition-all duration-300 ease-in-out flex items-center justify-center;
    }

    .btn-blue {
        @apply bg-gradient-to-r from-blue-500 to-blue-700
               hover:from-blue-600 hover:to-blue-800
               disabled:bg-gray-400 disabled:from-gray-400 disabled:to-gray-400
               hover:shadow-xl hover:scale-105;
    }

    .btn-red {
        @apply bg-gradient-to-r from-red-500 to-red-700
               hover:from-red-600 hover:to-red-800
               hover:shadow-xl hover:scale-105;
    }

    .status-box {
        @apply mt-6 p-4 rounded-lg text-sm bg-blue-50 text-blue-800 border border-blue-200;
        background-color: rgba(240, 249, 255, 0.9);
    }

    .result-box {
        @apply mt-8 p-8 rounded-2xl shadow-xl text-white;
        background: linear-gradient(to bottom right, #3b82f6, #6366f1);
    }

    .result-text {
        @apply text-5xl font-extrabold tracking-wide;
        font-family: 'Poppins', sans-serif;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .spinner {
        border: 4px solid rgba(255,255,255,0.3);
        border-top: 4px solid #fff;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
        display: inline-block;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
</head>
<body>

<div class="card">
    <h1 class="text-4xl font-bold text-gray-800 mb-6">üéôÔ∏è Emotion AI</h1>
    <p class="status-box" id="status-message">Ready to record or upload!</p>

    <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 justify-center mt-8">
        <button id="record-button" class="btn btn-blue">üé§ Record</button>
        <button id="stop-button" class="btn btn-red" style="display:none;">‚èπ Stop</button>

        <label for="upload-input" class="btn btn-blue cursor-pointer" id="upload-label">
            ‚¨ÜÔ∏è Upload File
        </label>
        <input type="file" id="upload-input" class="hidden" accept="audio/*">
    </div>

    <div id="result-container" class="result-box" style="display:none;">
        <h2 class="text-xl font-medium text-blue-100 mb-3">Predicted Emotion:</h2>
        <p id="result-text" class="result-text"></p>
    </div>
</div>

<script>
    const API_ENDPOINT = 'http://127.0.0.1:5000/predict';

    const recordButton = document.getElementById('record-button');
    const stopButton = document.getElementById('stop-button');
    const uploadInput = document.getElementById('upload-input');
    const uploadLabel = document.getElementById('upload-label');
    const statusMessage = document.getElementById('status-message');
    const resultContainer = document.getElementById('result-container');
    const resultText = document.getElementById('result-text');

    let mediaRecorder, audioChunks = [];

    // --- RECORD ---
    recordButton.addEventListener('click', async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                sendAudioToServer(audioBlob);
            };

            mediaRecorder.start();
            updateUIForRecording(true);
        } catch (err) {
            console.error('Recording error:', err);
            statusMessage.textContent = 'üéß Microphone access denied or unavailable.';
        }
    });

    stopButton.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
            updateUIForRecording(false);
            statusMessage.innerHTML = '<div class="spinner"></div> Processing audio...';
        }
    });

    // --- UPLOAD ---
    uploadInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) {
            statusMessage.innerHTML = '<div class="spinner"></div> Uploading and analyzing...';
            resultContainer.style.display = 'none';
            sendAudioToServer(file);
            uploadInput.value = null;
        }
    });

    // --- SEND AUDIO ---
    async function sendAudioToServer(audioBlob) {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');

        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 15000);

            const response = await fetch(API_ENDPOINT, {
                method: 'POST',
                body: formData,
                signal: controller.signal
            });

            clearTimeout(timeout);

            if (!response.ok) {
                let err = await response.text();
                throw new Error(err || `Server responded with ${response.status}`);
            }

            const data = await response.json();
            resultText.textContent = data.emotion?.toUpperCase() || 'UNKNOWN';
            resultContainer.style.display = 'block';
            statusMessage.textContent = '‚úÖ Ready to record or upload again!';
        } catch (err) {
            console.error('Fetch error:', err);
            let reason = 'Cannot reach the server. Make sure `app.py` is running.';
            if (err.name === 'AbortError') reason = 'Request timed out (server not responding).';
            statusMessage.textContent = `‚ùå ${reason}`;
            resultContainer.style.display = 'none';
        } finally {
            updateUIForRecording(false);
        }
    }

    function updateUIForRecording(isRecording) {
        recordButton.style.display = isRecording ? 'none' : 'inline-flex';
        uploadLabel.style.display = isRecording ? 'none' : 'inline-flex';
        stopButton.style.display = isRecording ? 'inline-flex' : 'none';
    }
</script>

</body>
</html>
